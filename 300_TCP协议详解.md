## TCP的特点
- 基于字节流
- 面向连接
- 可靠传输

这种连接必须是 1 对 1,因此广播和多播的应用程序不能使用 TCP 服务

TCP是可靠的.TCP 采用应答机制,发送的每一个 TCP 报文必须得到接收方的应答,才认为这个 TCP 报文段传输成功,不然就要重新传送.

## 一个错误
我抓了个包看了下,3次 TCP 握手没问题,但是四次挥手是不完全通用的.![Alt text](image.png)

我问了下 chat GPT,他的回答如下:
您是对的，我之前的回答并不完全准确，因为在TCP四次挥手的ACK序号方面，有两种情况：

ACK的序号是对方的序列号：在某些情况下，ACK的序号是对方的序列号，而不是对方的序列号加1。这通常发生在接收到数据后，需要确认接收到的数据。

ACK的序号是对方的序列号加1：在其他情况下，ACK的序号是对方的序列号加1。这通常发生在发送端主动关闭连接时，发送FIN并等待对方的ACK确认。

具体是哪种情况取决于连接的状态和数据的传输情况。因此，在TCP四次挥手过程中，ACK的序号可以是对方的序列号，也可以是对方的序列号加1，具体取决于每一步的操作和状态。

感谢您的纠正，希望这一点能够更好地解释ACK序号的不同情况。
## TCP连接状态转移图
![Alt text](image-1.png)

这个图非常好,我把它画出来挂在桌子前方时常观察.

### 问题:如果客户端发了 FIN 之后,也没接收到 ACK(或者接收到了),那么长时间处于 FIN_WAIT_1或者FIN_WAIT_2 状态,将会发生什么?

答案是:此时的客户端连接由内核来接管,就像那个被 init 程序接管的孤儿进程,这种连接被称为孤儿连接.孤儿连接有生存时间,时间一到,就自动发一个 ACK,服务器也会从 LAST_ACK结束连接.

### 问题:为什么要在 TIME_WAIT 阶段等待一会儿

因为万一 ACK 没有发出去,服务器就会重复发送 FIN,而这时,客户端结束了,无法继续重传 ACK,那服务器就会认为这是一个错误.

如果在 TIME_WAIT 阶段等会儿,如果没有再收到 FIN,那么客户端就会认为服务端已经收到了 ACK,这样就会安全关闭.

这个状态一般会维持 2MSL,也就是 4 分钟.这是 TCP 报文最大生存时间.

在 linux 上,一个TCP 端口不能被打开多次,如果关闭后,另一个程序立即使用它,那么就会导致客户端和服务器不匹配的错误.

最后一个原因,由于 TCP 报文段的MSL 为 2 分钟.假设 失去动静1分59 秒后服务器收到了一个 ACK,然后又发送了一个 ACK;又过了 1 分 59 秒,客户端收到了来自服务端的 ACK.这样,比较极限的情况下,接近 4 分钟客户端再一次收到了来自服务器的消息,说明还没有彻底断开.
反之,如果 4 分钟之内都没有任何动静,那么整个链路上都没有和原来连接有关的数据包了.这样就可以建立新的连接了!

有时候,我们希望立即重启一个程序,但是由于2MSL,不得不等 4 分钟.有什么好的办法?

对于客户端,这个无所谓,我们的客户端使用系统自动分配的端口来进行建立连接,重启都可以启动成功.

对于服务器主动关闭后,我们可以利用 SOCKET中的某些字段,比如 SO_REUSEADDR把手伸进 TCP 内核处,强制进程立即使用 TIME_WAIT状态的连接占用的端口,来解决这个问题.这个将在第 5 章讨论.






